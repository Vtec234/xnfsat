// Copyright (2021) Armin Biere, JKU Linz.

/*------------------------------------------------------------------------*/

#define VERSION "0.0"

// *INDENT-OFF*

const char * usage = 
"usage: extor [ <option> ... ] <extension> <witness>"
"\n"
"\nThe '<option>' argument is one of the following:\n"
"\n"
"  --version      print version and exit\n"
"  -h | --help    print this command line option summary\n"
"  -q | --quiet   do not print verbose message\n"
"\n"
""
"The '<extension>' file is the reconstruction stack generated by\n"
"'cnf2xor' if it is given a third file argument.  The '<witness>'\n"
"file is expected to contain the output of a SAT solver following\n"
"the SAT Competition format.  The tool will then parse the output\n"
"and search for a 's SATISFIABLE' line and corresponding 'v ...'\n"
"lines.  If no 's SATISFIABLE' line is found the tool simple exits\n"
"after printing 's UNSATISFIABLE' if a such a line is found instead.\n"
"Otherwise the 'v ...' lines are parsed and an assignment is extracted.\n"
"This assignment is extended with the XNF extention stack in '<extension>'\n"
"and printed also as 'v ...' lines to '<stdout>' after printing the\n"
"'s SATISFIABLE'.  Accordingly the resulting output should be a witness\n"
"for the original CNF.\n"
;

// *INDENT-ON*

/*------------------------------------------------------------------------*/

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/*------------------------------------------------------------------------*/

#define SIZE(S) ((int)((S).end - (S).begin))
#define FULL(S) ((S).end == (S).allocated)
#define EMPTY(S) ((S).begin == (S).end)
#define CLEAR(S) do { (S).end = (S).begin; } while (0)

#define ENLARGE(S) \
do { \
  assert (FULL (S)); \
  size_t OLD_SIZE = SIZE (S); \
  size_t NEW_SIZE = OLD_SIZE ? 2*OLD_SIZE : 1; \
  size_t NEW_BYTES = NEW_SIZE * sizeof *(S).begin; \
  (S).begin = realloc ((S).begin, NEW_BYTES); \
  if (!(S).begin) \
    out_of_memory (); \
  (S).end = (S).begin + OLD_SIZE; \
  (S).allocated = (S).begin + NEW_SIZE; \
} while (0)

#define PUSH(S,E) \
do { \
  if (FULL (S)) \
    ENLARGE (S); \
  *(S).end++ = (E); \
} while (0)

#define all_literals(L,C) \
  int L, * L ## _PTR = (C)->literals, \
         * L ## _END = L ## _PTR + (C)->size; \
  (L ## _PTR != L ## _END) && (L = *L ## _PTR, true); \
  ++L ## _PTR

#define all_constraints(C) \
  struct constraint * C, ** C ## _PTR = (constraints).end, \
                         ** C ## _BEGIN = (constraints).begin; \
  (C ## _PTR-- != C ## _BEGIN) && (C = *C ## _PTR, true);

/*------------------------------------------------------------------------*/

struct literals
{
  int * begin, * end, * allocated;
};

struct constraint
{
  bool xor;
  unsigned size:31;
  int literals[];
};

struct constraints
{
  struct constraint ** begin, ** end, ** allocated;
};

/*------------------------------------------------------------------------*/

static bool quiet;

static const char * error_path;
static const char * extension_path;
static const char * witness_path;

/*------------------------------------------------------------------------*/

static FILE * extension_file;
static FILE * witness_file;

/*------------------------------------------------------------------------*/

static int vars;
static unsigned capacity;
static signed char * values;
static struct literals literals;
static struct constraints constraints;

/*------------------------------------------------------------------------*/

static char buffer[80];
static int size_buffer;

/*------------------------------------------------------------------------*/

static double
percent (double a, double b)
{
  return b ? 100.0 * a / b : 0;
}

#include <sys/time.h>
#include <sys/resource.h>

static double
timevoid (void)
{
  struct rusage u;
  if (getrusage (RUSAGE_SELF, &u))
    return 0;
  double res = u.ru_utime.tv_sec + 1e-6 * u.ru_utime.tv_usec;
  res += u.ru_stime.tv_sec + 1e-6 * u.ru_stime.tv_usec;
  return res;
}

/*------------------------------------------------------------------------*/

static void die (const char *, ...) __attribute__((format (printf, 1, 2)));
static void msg (const char *, ...) __attribute__((format (printf, 1, 2)));

static void
die (const char *fmt, ...)
{
  fputs ("extor: error: ", stderr);
  va_list ap;
  va_start (ap, fmt);
  vfprintf (stderr, fmt, ap);
  va_end (ap);
  if (error_path)
    fprintf (stderr, " in '%s'", error_path);
  fputc ('\n', stderr);
  exit (1);
}

static void
out_of_memory (void)
{
  die ("out-of-memory");
}

static void
msg (const char *fmt, ...)
{
  if (quiet)
    return;
  fputs ("c ", stdout);
  va_list ap;
  va_start (ap, fmt);
  vfprintf (stdout, fmt, ap);
  va_end (ap);
  fputc ('\n', stdout);
  fflush (stdout);
}

/*------------------------------------------------------------------------*/

static void
increase_capacity (unsigned new_vars)
{
  assert (0 < new_vars);
  assert (new_vars < (1u<<30));
  unsigned new_capacity = capacity ? 2u*capacity : 1;
  while (new_capacity <= new_vars)
    new_capacity *= 2;
  const size_t bytes = 2u * new_capacity + 1;
  signed char * new_values = malloc (bytes);
  if (!new_values)
    out_of_memory ();
  memset (new_values, 1, new_capacity);
  new_values += new_capacity;
  memset (new_values, -1, new_capacity);
  if (vars)
    memcpy (new_values - vars, values - vars, 2u*vars + 1);
  values -= capacity;
  free (values);
  values = new_values;
  capacity = new_capacity;
}

static void
increase_variables (int new_vars)
{
  assert (0 < new_vars);
  if (new_vars < vars)
    return;
  if (new_vars >= capacity)
    increase_capacity (new_vars);
  vars = new_vars;
}

/*------------------------------------------------------------------------*/

static int
next_char (FILE * file, size_t * lineno)
{
  int ch = getc (file);
  if (ch == '\n')
    *lineno += 1;
  return ch;
}

static bool
is_white_space (int ch)
{
  return ch == ' ' || ch == '\t' || ch == '\n';
}

static int
parse_literal (FILE * file, 
               bool skip_v_line_prefix_after_new_line,
	       const char * context, size_t * lineno)
{
  int ch, previous;

SKIP_WHITE_SPACE:

  previous = 0;
  while (is_white_space (ch = next_char (file, lineno)))
    previous = ch;

  if (ch == EOF)
    die ("unexpected end-of-file after '%s' at line %zu",
         context, *lineno);

  if (skip_v_line_prefix_after_new_line && previous == '\n' && ch == 'v')
    goto SKIP_WHITE_SPACE;

  int sign = 1;
  if (ch == '-')
    {
      sign = -1;
      ch = next_char (file, lineno);
    }

  if (!isdigit (ch))
    die ("expected digit after '%s' at line %zu",
         context, *lineno - (ch == '\n'));

  int idx = ch - '0';
  while (isdigit (ch = next_char (file, lineno)))
    {
      if (INT_MAX/10 < idx)
        die ("literal way too large after '%s' at line %zu",
	     context, *lineno);
      idx *= 10;
      const int digit = ch - '0';
      if (INT_MAX - digit < idx)
        die ("literal too large after '%s' at line %zu",
	     context, *lineno);
      idx += digit;
    }
  if (idx)
    increase_variables (idx);

  const int res = sign * idx;

  if (ch == EOF)
    die ("unexpected end-of-line after '%d' at line %zu", res, *lineno);
  if (!is_white_space (ch))
    die ("expected white space after '%d' at line %zu", res, *lineno);

  ungetc (ch, file);
  if (ch == '\n')
    *lineno -= 1;

  return res;
}

static void
parse_status (const char * str, FILE * file, size_t lineno)
{
  const char * p = str;
  int ch = 0;
  while (*p && *p == (ch = getc (file)))
    assert (ch != '\n'), p++;

  if (*p)
    die ("invalid status line at %zu", lineno);

  while ((ch = getc (file)) == ' ' || ch == '\t')
    ;

  if (ch != '\n')
    die ("incomplete status line at %zu", lineno);

  ungetc (ch, file);
}

static int
parse_witness (void)
{
  msg ("parsing witness file '%s'", error_path = witness_path);
  int res = 0, ch;
  size_t lineno = 1;
  for (;;)
    {
      ch = next_char (witness_file, &lineno);
      if (ch == EOF)
	break;
      else if (ch == 'v')
	{
	  int lit;
	  while ((lit = parse_literal (witness_file, true, "v", &lineno)))
	    if (lit)
	      values[lit] = 1, values[-lit] = -1;
	}
      else if (ch == 's')
	{
	  if (res)
	    die ("second 's' line %zu", lineno);
	  if ((ch = next_char (witness_file, &lineno)) == ' ')
	    {
	      if ((ch = next_char (witness_file, &lineno)) == 'S')
		{
		  parse_status ("ATISFIABLE", witness_file, lineno);
		  msg ("found 's SATISFIABLE' at line %zu", lineno);
		  res = 10;
		}
	      else if (ch == 'U')
		{
		  parse_status ("NSATISFIABLE", witness_file, lineno);
		  msg ("found 's UNSATISFIABLE' at line %zu", lineno);
		  res = 20;
		}
	      else
		goto INVALID_STATUS_LINE;

	      ch = next_char (witness_file, &lineno);
	    }
	  else
	    {
INVALID_STATUS_LINE:
	      die ("invalid status line at line %zu",
		   lineno - (ch == '\n'));
	    }
	}
      else if (ch == '\n')
	die ("invalid empty line %zu", lineno);
      else if (ch != 'c')
	die ("invalid line %zu", lineno);

      while (ch != '\n' && ch != EOF)
	ch = next_char (witness_file, &lineno);

      lineno++;
    }
  error_path = 0;
  return res;
}

/*------------------------------------------------------------------------*/

static void
parse_extension (void)
{
  msg ("parsing extension file '%s'", error_path = extension_path);

  size_t xor_constraints = 0;
  size_t or_constraints = 0;
  size_t lineno = 1;

  for (;;)
    {
      int type = next_char (extension_file, &lineno);
      if (type == '\n')
	continue;
      if (type == EOF)
	break;
      if (type != 'x' && type != 'o')
	die ("invalid line %zu", lineno);
      int lit;
      const char context[2] = { type, 0 };
      assert (EMPTY (literals));
      while ((lit = parse_literal (extension_file, false, context, &lineno)))
	PUSH (literals, lit);
      const size_t size = SIZE (literals);
      if (size >= (1u <<31))
	die ("constraint at line %zu too large", lineno);
      size_t literals_bytes = size * sizeof (int);
      size_t bytes = sizeof (struct constraint) + literals_bytes;
      struct constraint * c = malloc (bytes);
      if (!c)
	out_of_memory ();
      PUSH (constraints, c);
      c->xor = (type == 'x');
      c->size = size;
      memcpy (c->literals, literals.begin, literals_bytes);
      CLEAR (literals);
      if (type == 'x')
	xor_constraints++;
      else
	or_constraints++;
    }

  const size_t constraints = xor_constraints + or_constraints;
  msg ("parsed %zu lines (%zu XORs %.0f%%, %zu ORs %.0f%%)",
       constraints,
       xor_constraints, percent (xor_constraints, constraints),
       or_constraints, percent (or_constraints, constraints));
  error_path = 0;
}

/*------------------------------------------------------------------------*/

static void
extend_witness (void)
{
  msg ("maximum variable index %d", vars);
  size_t flipped = 0;
  for (all_constraints (c))
    {
      bool satisfied = false;
      assert (c->size > 0);
      if (c->xor)
	{
	  for (all_literals (lit, c))
	    if (values[lit] > 0)
	      satisfied = !satisfied;
	}
      else
	{
	  for (all_literals (lit, c))
	    if (values[lit] > 0)
	      satisfied = true;
	}
      if (satisfied)
	continue;
      int flip = c->literals[0];
      values[flip] *= -1;
      values[-flip] *= -1;
      flipped++;
    }
  msg ("flipped %zu literals", flipped);
}

/*------------------------------------------------------------------------*/

static void
flush_buffer (void)
{
  assert (size_buffer);
  assert (size_buffer < sizeof buffer);
  buffer[size_buffer] = 0;
  fputs (buffer, stdout);
  fputc ('\n', stdout);
  size_buffer = 0;
}

static void
print_value (int lit)
{
  if (!size_buffer)
    buffer[size_buffer++] = 'v';
  char tmp[32];
  sprintf (tmp, " %d", lit);
  size_t len = strlen (tmp);
  if (size_buffer + len >= 76)
    {
      flush_buffer ();
      buffer[size_buffer++] = 'v';
    }
  const char * p = tmp;
  while (*p)
    assert (size_buffer < sizeof buffer), buffer[size_buffer++] = *p++;
}

/*------------------------------------------------------------------------*/

static void
reset (void)
{
  for (all_constraints (c))
    free (c);
  free (constraints.begin);

  values -= capacity;
  free (values);

  free (literals.begin);
}

/*------------------------------------------------------------------------*/

int
main (int argc, char ** argv)
{
  for (int i = 1; i < argc; i++)
    {
      const char * arg = argv[i];
      if (!strcmp (arg, "-h") || !strcmp (arg, "--help"))
	fputs (usage, stdout), exit (0);
      else if (!strcmp (arg, "--version"))
	printf ("%s\n", VERSION), exit (0);
      else if (!strcmp (arg, "-q") || !strcmp (arg, "--quiet"))
	quiet = true;
      else if (witness_path)
	die ("too many file arguments '%s', '%s' and '%s'",
	     extension_path, witness_path, arg);
      else if (extension_path)
	witness_path = arg;
      else
	extension_path = arg;
    }

  if (!witness_path)
    die ("witness file missing (try '-h'))");

  if (!extension_path)
    die ("extension file missing (try '-h'))");

  if (!(witness_file = fopen (witness_path, "r")))
    die ("could not read witness file '%s'", witness_path);

  if (!(extension_file = fopen (extension_path, "r")))
    die ("could not read extension file '%s'", extension_path);

  msg ("EXTOR witness XNF extender Version " VERSION);

  int res = parse_witness ();
  fclose (witness_file);

  if (res == 10)
    {
      parse_extension ();
      extend_witness ();
    }
  fclose (extension_file);

  if (res == 10)
    {
      printf ("s SATISFIABLE\n");
      for (int idx = 1; idx <= vars; idx++)
	print_value (values[idx] <= 0 ? -idx : idx);
      print_value (0);
      flush_buffer ();
    }
  else if (res == 20)
    printf ("s UNSATISFIABLE\n");

  reset ();

  msg ("extended witness in %.2f seconds", timevoid ());

  return res;
}
